{"version":3,"file":"static/js/2858.f5d95cbf.chunk.js","mappings":"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","sources":["../node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js","../node_modules/@babel/runtime/helpers/esm/objectWithoutPropertiesLoose.js","../node_modules/@dytesdk/ui-kit/dist/esm/floating-ui.dom.esm-eabd20d7.js","../node_modules/@dytesdk/ui-kit/dist/esm/index-2b010b0f.js"],"sourcesContent":["import objectWithoutPropertiesLoose from \"./objectWithoutPropertiesLoose.js\";\nexport default function _objectWithoutProperties(source, excluded) {\n  if (source == null) return {};\n  var target = objectWithoutPropertiesLoose(source, excluded);\n  var key, i;\n  if (Object.getOwnPropertySymbols) {\n    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n    for (i = 0; i < sourceSymbolKeys.length; i++) {\n      key = sourceSymbolKeys[i];\n      if (excluded.indexOf(key) >= 0) continue;\n      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n      target[key] = source[key];\n    }\n  }\n  return target;\n}","export default function _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n  return target;\n}","function getSide(placement) {\n  return placement.split('-')[0];\n}\n\nfunction getAlignment(placement) {\n  return placement.split('-')[1];\n}\n\nfunction getMainAxisFromPlacement(placement) {\n  return ['top', 'bottom'].includes(getSide(placement)) ? 'x' : 'y';\n}\n\nfunction getLengthFromAxis(axis) {\n  return axis === 'y' ? 'height' : 'width';\n}\n\nfunction computeCoordsFromPlacement(_ref, placement, rtl) {\n  let {\n    reference,\n    floating\n  } = _ref;\n  const commonX = reference.x + reference.width / 2 - floating.width / 2;\n  const commonY = reference.y + reference.height / 2 - floating.height / 2;\n  const mainAxis = getMainAxisFromPlacement(placement);\n  const length = getLengthFromAxis(mainAxis);\n  const commonAlign = reference[length] / 2 - floating[length] / 2;\n  const side = getSide(placement);\n  const isVertical = mainAxis === 'x';\n  let coords;\n  switch (side) {\n    case 'top':\n      coords = {\n        x: commonX,\n        y: reference.y - floating.height\n      };\n      break;\n    case 'bottom':\n      coords = {\n        x: commonX,\n        y: reference.y + reference.height\n      };\n      break;\n    case 'right':\n      coords = {\n        x: reference.x + reference.width,\n        y: commonY\n      };\n      break;\n    case 'left':\n      coords = {\n        x: reference.x - floating.width,\n        y: commonY\n      };\n      break;\n    default:\n      coords = {\n        x: reference.x,\n        y: reference.y\n      };\n  }\n  switch (getAlignment(placement)) {\n    case 'start':\n      coords[mainAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);\n      break;\n    case 'end':\n      coords[mainAxis] += commonAlign * (rtl && isVertical ? -1 : 1);\n      break;\n  }\n  return coords;\n}\n\n/**\n * Computes the `x` and `y` coordinates that will place the floating element\n * next to a reference element when it is given a certain positioning strategy.\n *\n * This export does not have any `platform` interface logic. You will need to\n * write one for the platform you are using Floating UI with.\n */\nconst computePosition$1 = async (reference, floating, config) => {\n  const {\n    placement = 'bottom',\n    strategy = 'absolute',\n    middleware = [],\n    platform\n  } = config;\n  const validMiddleware = middleware.filter(Boolean);\n  const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(floating));\n  let rects = await platform.getElementRects({\n    reference,\n    floating,\n    strategy\n  });\n  let {\n    x,\n    y\n  } = computeCoordsFromPlacement(rects, placement, rtl);\n  let statefulPlacement = placement;\n  let middlewareData = {};\n  let resetCount = 0;\n  for (let i = 0; i < validMiddleware.length; i++) {\n    const {\n      name,\n      fn\n    } = validMiddleware[i];\n    const {\n      x: nextX,\n      y: nextY,\n      data,\n      reset\n    } = await fn({\n      x,\n      y,\n      initialPlacement: placement,\n      placement: statefulPlacement,\n      strategy,\n      middlewareData,\n      rects,\n      platform,\n      elements: {\n        reference,\n        floating\n      }\n    });\n    x = nextX != null ? nextX : x;\n    y = nextY != null ? nextY : y;\n    middlewareData = {\n      ...middlewareData,\n      [name]: {\n        ...middlewareData[name],\n        ...data\n      }\n    };\n    if (reset && resetCount <= 50) {\n      resetCount++;\n      if (typeof reset === 'object') {\n        if (reset.placement) {\n          statefulPlacement = reset.placement;\n        }\n        if (reset.rects) {\n          rects = reset.rects === true ? await platform.getElementRects({\n            reference,\n            floating,\n            strategy\n          }) : reset.rects;\n        }\n        ({\n          x,\n          y\n        } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));\n      }\n      i = -1;\n      continue;\n    }\n  }\n  return {\n    x,\n    y,\n    placement: statefulPlacement,\n    strategy,\n    middlewareData\n  };\n};\n\nfunction expandPaddingObject(padding) {\n  return {\n    top: 0,\n    right: 0,\n    bottom: 0,\n    left: 0,\n    ...padding\n  };\n}\n\nfunction getSideObjectFromPadding(padding) {\n  return typeof padding !== 'number' ? expandPaddingObject(padding) : {\n    top: padding,\n    right: padding,\n    bottom: padding,\n    left: padding\n  };\n}\n\nfunction rectToClientRect(rect) {\n  return {\n    ...rect,\n    top: rect.y,\n    left: rect.x,\n    right: rect.x + rect.width,\n    bottom: rect.y + rect.height\n  };\n}\n\n/**\n * Resolves with an object of overflow side offsets that determine how much the\n * element is overflowing a given clipping boundary.\n * - positive = overflowing the boundary by that number of pixels\n * - negative = how many pixels left before it will overflow\n * - 0 = lies flush with the boundary\n * @see https://floating-ui.com/docs/detectOverflow\n */\nasync function detectOverflow(middlewareArguments, options) {\n  var _await$platform$isEle;\n  if (options === void 0) {\n    options = {};\n  }\n  const {\n    x,\n    y,\n    platform,\n    rects,\n    elements,\n    strategy\n  } = middlewareArguments;\n  const {\n    boundary = 'clippingAncestors',\n    rootBoundary = 'viewport',\n    elementContext = 'floating',\n    altBoundary = false,\n    padding = 0\n  } = options;\n  const paddingObject = getSideObjectFromPadding(padding);\n  const altContext = elementContext === 'floating' ? 'reference' : 'floating';\n  const element = elements[altBoundary ? altContext : elementContext];\n  const clippingClientRect = rectToClientRect(await platform.getClippingRect({\n    element: ((_await$platform$isEle = await (platform.isElement == null ? void 0 : platform.isElement(element))) != null ? _await$platform$isEle : true) ? element : element.contextElement || (await (platform.getDocumentElement == null ? void 0 : platform.getDocumentElement(elements.floating))),\n    boundary,\n    rootBoundary,\n    strategy\n  }));\n  const rect = elementContext === 'floating' ? {\n    ...rects.floating,\n    x,\n    y\n  } : rects.reference;\n  const offsetParent = await (platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(elements.floating));\n  const offsetScale = (await (platform.isElement == null ? void 0 : platform.isElement(offsetParent))) ? (await (platform.getScale == null ? void 0 : platform.getScale(offsetParent))) || {\n    x: 1,\n    y: 1\n  } : {\n    x: 1,\n    y: 1\n  };\n  const elementClientRect = rectToClientRect(platform.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform.convertOffsetParentRelativeRectToViewportRelativeRect({\n    rect,\n    offsetParent,\n    strategy\n  }) : rect);\n  return {\n    top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,\n    bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,\n    left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,\n    right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x\n  };\n}\n\nconst min$1 = Math.min;\nconst max$1 = Math.max;\n\nfunction within(min$1$1, value, max$1$1) {\n  return max$1(min$1$1, min$1(value, max$1$1));\n}\n\n/**\n * Positions an inner element of the floating element such that it is centered\n * to the reference element.\n * @see https://floating-ui.com/docs/arrow\n */\nconst arrow = options => ({\n  name: 'arrow',\n  options,\n  async fn(middlewareArguments) {\n    // Since `element` is required, we don't Partial<> the type\n    const {\n      element,\n      padding = 0\n    } = options != null ? options : {};\n    const {\n      x,\n      y,\n      placement,\n      rects,\n      platform\n    } = middlewareArguments;\n    if (element == null) {\n      return {};\n    }\n    const paddingObject = getSideObjectFromPadding(padding);\n    const coords = {\n      x,\n      y\n    };\n    const axis = getMainAxisFromPlacement(placement);\n    const length = getLengthFromAxis(axis);\n    const arrowDimensions = await platform.getDimensions(element);\n    const minProp = axis === 'y' ? 'top' : 'left';\n    const maxProp = axis === 'y' ? 'bottom' : 'right';\n    const endDiff = rects.reference[length] + rects.reference[axis] - coords[axis] - rects.floating[length];\n    const startDiff = coords[axis] - rects.reference[axis];\n    const arrowOffsetParent = await (platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(element));\n    let clientSize = arrowOffsetParent ? axis === 'y' ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;\n    if (clientSize === 0) {\n      clientSize = rects.floating[length];\n    }\n    const centerToReference = endDiff / 2 - startDiff / 2;\n\n    // Make sure the arrow doesn't overflow the floating element if the center\n    // point is outside the floating element's bounds\n    const min = paddingObject[minProp];\n    const max = clientSize - arrowDimensions[length] - paddingObject[maxProp];\n    const center = clientSize / 2 - arrowDimensions[length] / 2 + centerToReference;\n    const offset = within(min, center, max);\n\n    // If the reference is small enough that the arrow's padding causes it to\n    // to point to nothing for an aligned placement, adjust the offset of the\n    // floating element itself. This stops `shift()` from taking action, but can\n    // be worked around by calling it again after the `arrow()` if desired.\n    const shouldAddOffset = getAlignment(placement) != null && center != offset && rects.reference[length] / 2 - (center < min ? paddingObject[minProp] : paddingObject[maxProp]) - arrowDimensions[length] / 2 < 0;\n    const alignmentOffset = shouldAddOffset ? center < min ? min - center : max - center : 0;\n    return {\n      [axis]: coords[axis] - alignmentOffset,\n      data: {\n        [axis]: offset,\n        centerOffset: center - offset\n      }\n    };\n  }\n});\n\nconst hash$1 = {\n  left: 'right',\n  right: 'left',\n  bottom: 'top',\n  top: 'bottom'\n};\nfunction getOppositePlacement(placement) {\n  return placement.replace(/left|right|bottom|top/g, matched => hash$1[matched]);\n}\n\nfunction getAlignmentSides(placement, rects, rtl) {\n  if (rtl === void 0) {\n    rtl = false;\n  }\n  const alignment = getAlignment(placement);\n  const mainAxis = getMainAxisFromPlacement(placement);\n  const length = getLengthFromAxis(mainAxis);\n  let mainAlignmentSide = mainAxis === 'x' ? alignment === (rtl ? 'end' : 'start') ? 'right' : 'left' : alignment === 'start' ? 'bottom' : 'top';\n  if (rects.reference[length] > rects.floating[length]) {\n    mainAlignmentSide = getOppositePlacement(mainAlignmentSide);\n  }\n  return {\n    main: mainAlignmentSide,\n    cross: getOppositePlacement(mainAlignmentSide)\n  };\n}\n\nconst hash = {\n  start: 'end',\n  end: 'start'\n};\nfunction getOppositeAlignmentPlacement(placement) {\n  return placement.replace(/start|end/g, matched => hash[matched]);\n}\n\nfunction getExpandedPlacements(placement) {\n  const oppositePlacement = getOppositePlacement(placement);\n  return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];\n}\n\n/**\n * Changes the placement of the floating element to one that will fit if the\n * initially specified `placement` does not.\n * @see https://floating-ui.com/docs/flip\n */\nconst flip = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'flip',\n    options,\n    async fn(middlewareArguments) {\n      var _middlewareData$flip;\n      const {\n        placement,\n        middlewareData,\n        rects,\n        initialPlacement,\n        platform,\n        elements\n      } = middlewareArguments;\n      const {\n        mainAxis: checkMainAxis = true,\n        crossAxis: checkCrossAxis = true,\n        fallbackPlacements: specifiedFallbackPlacements,\n        fallbackStrategy = 'bestFit',\n        flipAlignment = true,\n        ...detectOverflowOptions\n      } = options;\n      const side = getSide(placement);\n      const isBasePlacement = side === initialPlacement;\n      const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));\n      const placements = [initialPlacement, ...fallbackPlacements];\n      const overflow = await detectOverflow(middlewareArguments, detectOverflowOptions);\n      const overflows = [];\n      let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];\n      if (checkMainAxis) {\n        overflows.push(overflow[side]);\n      }\n      if (checkCrossAxis) {\n        const {\n          main,\n          cross\n        } = getAlignmentSides(placement, rects, await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating)));\n        overflows.push(overflow[main], overflow[cross]);\n      }\n      overflowsData = [...overflowsData, {\n        placement,\n        overflows\n      }];\n\n      // One or more sides is overflowing\n      if (!overflows.every(side => side <= 0)) {\n        var _middlewareData$flip$, _middlewareData$flip2;\n        const nextIndex = ((_middlewareData$flip$ = (_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) != null ? _middlewareData$flip$ : 0) + 1;\n        const nextPlacement = placements[nextIndex];\n        if (nextPlacement) {\n          // Try next placement and re-run the lifecycle\n          return {\n            data: {\n              index: nextIndex,\n              overflows: overflowsData\n            },\n            reset: {\n              placement: nextPlacement\n            }\n          };\n        }\n        let resetPlacement = 'bottom';\n        switch (fallbackStrategy) {\n          case 'bestFit':\n            {\n              var _overflowsData$map$so;\n              const placement = (_overflowsData$map$so = overflowsData.map(d => [d, d.overflows.filter(overflow => overflow > 0).reduce((acc, overflow) => acc + overflow, 0)]).sort((a, b) => a[1] - b[1])[0]) == null ? void 0 : _overflowsData$map$so[0].placement;\n              if (placement) {\n                resetPlacement = placement;\n              }\n              break;\n            }\n          case 'initialPlacement':\n            resetPlacement = initialPlacement;\n            break;\n        }\n        if (placement !== resetPlacement) {\n          return {\n            reset: {\n              placement: resetPlacement\n            }\n          };\n        }\n      }\n      return {};\n    }\n  };\n};\n\nasync function convertValueToCoords(middlewareArguments, value) {\n  const {\n    placement,\n    platform,\n    elements\n  } = middlewareArguments;\n  const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating));\n  const side = getSide(placement);\n  const alignment = getAlignment(placement);\n  const isVertical = getMainAxisFromPlacement(placement) === 'x';\n  const mainAxisMulti = ['left', 'top'].includes(side) ? -1 : 1;\n  const crossAxisMulti = rtl && isVertical ? -1 : 1;\n  const rawValue = typeof value === 'function' ? value(middlewareArguments) : value;\n\n  // eslint-disable-next-line prefer-const\n  let {\n    mainAxis,\n    crossAxis,\n    alignmentAxis\n  } = typeof rawValue === 'number' ? {\n    mainAxis: rawValue,\n    crossAxis: 0,\n    alignmentAxis: null\n  } : {\n    mainAxis: 0,\n    crossAxis: 0,\n    alignmentAxis: null,\n    ...rawValue\n  };\n  if (alignment && typeof alignmentAxis === 'number') {\n    crossAxis = alignment === 'end' ? alignmentAxis * -1 : alignmentAxis;\n  }\n  return isVertical ? {\n    x: crossAxis * crossAxisMulti,\n    y: mainAxis * mainAxisMulti\n  } : {\n    x: mainAxis * mainAxisMulti,\n    y: crossAxis * crossAxisMulti\n  };\n}\n\n/**\n * Displaces the floating element from its reference element.\n * @see https://floating-ui.com/docs/offset\n */\nconst offset = function (value) {\n  if (value === void 0) {\n    value = 0;\n  }\n  return {\n    name: 'offset',\n    options: value,\n    async fn(middlewareArguments) {\n      const {\n        x,\n        y\n      } = middlewareArguments;\n      const diffCoords = await convertValueToCoords(middlewareArguments, value);\n      return {\n        x: x + diffCoords.x,\n        y: y + diffCoords.y,\n        data: diffCoords\n      };\n    }\n  };\n};\n\nfunction getCrossAxis(axis) {\n  return axis === 'x' ? 'y' : 'x';\n}\n\n/**\n * Shifts the floating element in order to keep it in view when it will overflow\n * a clipping boundary.\n * @see https://floating-ui.com/docs/shift\n */\nconst shift = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'shift',\n    options,\n    async fn(middlewareArguments) {\n      const {\n        x,\n        y,\n        placement\n      } = middlewareArguments;\n      const {\n        mainAxis: checkMainAxis = true,\n        crossAxis: checkCrossAxis = false,\n        limiter = {\n          fn: _ref => {\n            let {\n              x,\n              y\n            } = _ref;\n            return {\n              x,\n              y\n            };\n          }\n        },\n        ...detectOverflowOptions\n      } = options;\n      const coords = {\n        x,\n        y\n      };\n      const overflow = await detectOverflow(middlewareArguments, detectOverflowOptions);\n      const mainAxis = getMainAxisFromPlacement(getSide(placement));\n      const crossAxis = getCrossAxis(mainAxis);\n      let mainAxisCoord = coords[mainAxis];\n      let crossAxisCoord = coords[crossAxis];\n      if (checkMainAxis) {\n        const minSide = mainAxis === 'y' ? 'top' : 'left';\n        const maxSide = mainAxis === 'y' ? 'bottom' : 'right';\n        const min = mainAxisCoord + overflow[minSide];\n        const max = mainAxisCoord - overflow[maxSide];\n        mainAxisCoord = within(min, mainAxisCoord, max);\n      }\n      if (checkCrossAxis) {\n        const minSide = crossAxis === 'y' ? 'top' : 'left';\n        const maxSide = crossAxis === 'y' ? 'bottom' : 'right';\n        const min = crossAxisCoord + overflow[minSide];\n        const max = crossAxisCoord - overflow[maxSide];\n        crossAxisCoord = within(min, crossAxisCoord, max);\n      }\n      const limitedCoords = limiter.fn({\n        ...middlewareArguments,\n        [mainAxis]: mainAxisCoord,\n        [crossAxis]: crossAxisCoord\n      });\n      return {\n        ...limitedCoords,\n        data: {\n          x: limitedCoords.x - x,\n          y: limitedCoords.y - y\n        }\n      };\n    }\n  };\n};\n\nfunction getWindow(node) {\n  var _node$ownerDocument;\n  return ((_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;\n}\n\nfunction getComputedStyle$1(element) {\n  return getWindow(element).getComputedStyle(element);\n}\n\nfunction getNodeName(node) {\n  return isNode(node) ? (node.nodeName || '').toLowerCase() : '';\n}\n\nlet uaString;\nfunction getUAString() {\n  if (uaString) {\n    return uaString;\n  }\n  const uaData = navigator.userAgentData;\n  if (uaData && Array.isArray(uaData.brands)) {\n    uaString = uaData.brands.map(item => item.brand + \"/\" + item.version).join(' ');\n    return uaString;\n  }\n  return navigator.userAgent;\n}\n\nfunction isHTMLElement(value) {\n  return value instanceof getWindow(value).HTMLElement;\n}\nfunction isElement(value) {\n  return value instanceof getWindow(value).Element;\n}\nfunction isNode(value) {\n  return value instanceof getWindow(value).Node;\n}\nfunction isShadowRoot(node) {\n  // Browsers without `ShadowRoot` support\n  if (typeof ShadowRoot === 'undefined') {\n    return false;\n  }\n  const OwnElement = getWindow(node).ShadowRoot;\n  return node instanceof OwnElement || node instanceof ShadowRoot;\n}\nfunction isOverflowElement(element) {\n  const {\n    overflow,\n    overflowX,\n    overflowY,\n    display\n  } = getComputedStyle$1(element);\n  return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && !['inline', 'contents'].includes(display);\n}\nfunction isTableElement(element) {\n  return ['table', 'td', 'th'].includes(getNodeName(element));\n}\nfunction isContainingBlock(element) {\n  // TODO: Try and use feature detection here instead\n  const isFirefox = /firefox/i.test(getUAString());\n  const css = getComputedStyle$1(element);\n  const backdropFilter = css.backdropFilter || css.WebkitBackdropFilter;\n\n  // This is non-exhaustive but covers the most common CSS properties that\n  // create a containing block.\n  // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block\n  return css.transform !== 'none' || css.perspective !== 'none' || (backdropFilter ? backdropFilter !== 'none' : false) || isFirefox && css.willChange === 'filter' || isFirefox && (css.filter ? css.filter !== 'none' : false) || ['transform', 'perspective'].some(value => css.willChange.includes(value)) || ['paint', 'layout', 'strict', 'content'].some(\n  // TS 4.1 compat\n  value => {\n    const contain = css.contain;\n    return contain != null ? contain.includes(value) : false;\n  });\n}\nfunction isLayoutViewport() {\n  // Not Safari\n  return !/^((?!chrome|android).)*safari/i.test(getUAString());\n  // Feature detection for this fails in various ways\n  //  Always-visible scrollbar or not\n  //  Width of <html>, etc.\n  // const vV = win.visualViewport;\n  // return vV ? Math.abs(win.innerWidth / vV.scale - vV.width) < 0.5 : true;\n}\n\nfunction isLastTraversableNode(node) {\n  return ['html', 'body', '#document'].includes(getNodeName(node));\n}\n\nconst min = Math.min;\nconst max = Math.max;\nconst round = Math.round;\n\nfunction getCssDimensions(element) {\n  const css = getComputedStyle$1(element);\n  let width = parseFloat(css.width);\n  let height = parseFloat(css.height);\n  const offsetWidth = element.offsetWidth;\n  const offsetHeight = element.offsetHeight;\n  const shouldFallback = round(width) !== offsetWidth || round(height) !== offsetHeight;\n  if (shouldFallback) {\n    width = offsetWidth;\n    height = offsetHeight;\n  }\n  return {\n    width,\n    height,\n    fallback: shouldFallback\n  };\n}\n\nfunction unwrapElement(element) {\n  return !isElement(element) ? element.contextElement : element;\n}\n\nconst FALLBACK_SCALE = {\n  x: 1,\n  y: 1\n};\nfunction getScale(element) {\n  const domElement = unwrapElement(element);\n  if (!isHTMLElement(domElement)) {\n    return FALLBACK_SCALE;\n  }\n  const rect = domElement.getBoundingClientRect();\n  const {\n    width,\n    height,\n    fallback\n  } = getCssDimensions(domElement);\n  let x = (fallback ? round(rect.width) : rect.width) / width;\n  let y = (fallback ? round(rect.height) : rect.height) / height;\n\n  // 0, NaN, or Infinity should always fallback to 1.\n\n  if (!x || !Number.isFinite(x)) {\n    x = 1;\n  }\n  if (!y || !Number.isFinite(y)) {\n    y = 1;\n  }\n  return {\n    x,\n    y\n  };\n}\n\nfunction getBoundingClientRect(element, includeScale, isFixedStrategy, offsetParent) {\n  var _win$visualViewport, _win$visualViewport2;\n  if (includeScale === void 0) {\n    includeScale = false;\n  }\n  if (isFixedStrategy === void 0) {\n    isFixedStrategy = false;\n  }\n  const clientRect = element.getBoundingClientRect();\n  const domElement = unwrapElement(element);\n  let scale = FALLBACK_SCALE;\n  if (includeScale) {\n    if (offsetParent) {\n      if (isElement(offsetParent)) {\n        scale = getScale(offsetParent);\n      }\n    } else {\n      scale = getScale(element);\n    }\n  }\n  const win = domElement ? getWindow(domElement) : window;\n  const addVisualOffsets = !isLayoutViewport() && isFixedStrategy;\n  let x = (clientRect.left + (addVisualOffsets ? ((_win$visualViewport = win.visualViewport) == null ? void 0 : _win$visualViewport.offsetLeft) || 0 : 0)) / scale.x;\n  let y = (clientRect.top + (addVisualOffsets ? ((_win$visualViewport2 = win.visualViewport) == null ? void 0 : _win$visualViewport2.offsetTop) || 0 : 0)) / scale.y;\n  let width = clientRect.width / scale.x;\n  let height = clientRect.height / scale.y;\n  if (domElement) {\n    const win = getWindow(domElement);\n    const offsetWin = offsetParent && isElement(offsetParent) ? getWindow(offsetParent) : offsetParent;\n    let currentIFrame = win.frameElement;\n    while (currentIFrame && offsetParent && offsetWin !== win) {\n      const iframeScale = getScale(currentIFrame);\n      const iframeRect = currentIFrame.getBoundingClientRect();\n      const css = getComputedStyle(currentIFrame);\n      iframeRect.x += (currentIFrame.clientLeft + parseFloat(css.paddingLeft)) * iframeScale.x;\n      iframeRect.y += (currentIFrame.clientTop + parseFloat(css.paddingTop)) * iframeScale.y;\n      x *= iframeScale.x;\n      y *= iframeScale.y;\n      width *= iframeScale.x;\n      height *= iframeScale.y;\n      x += iframeRect.x;\n      y += iframeRect.y;\n      currentIFrame = getWindow(currentIFrame).frameElement;\n    }\n  }\n  return {\n    width,\n    height,\n    top: y,\n    right: x + width,\n    bottom: y + height,\n    left: x,\n    x,\n    y\n  };\n}\n\nfunction getDocumentElement(node) {\n  return ((isNode(node) ? node.ownerDocument : node.document) || window.document).documentElement;\n}\n\nfunction getNodeScroll(element) {\n  if (isElement(element)) {\n    return {\n      scrollLeft: element.scrollLeft,\n      scrollTop: element.scrollTop\n    };\n  }\n  return {\n    scrollLeft: element.pageXOffset,\n    scrollTop: element.pageYOffset\n  };\n}\n\nfunction getWindowScrollBarX(element) {\n  // If <html> has a CSS width greater than the viewport, then this will be\n  // incorrect for RTL.\n  return getBoundingClientRect(getDocumentElement(element)).left + getNodeScroll(element).scrollLeft;\n}\n\nfunction getRectRelativeToOffsetParent(element, offsetParent, strategy) {\n  const isOffsetParentAnElement = isHTMLElement(offsetParent);\n  const documentElement = getDocumentElement(offsetParent);\n  const rect = getBoundingClientRect(element, true, strategy === 'fixed', offsetParent);\n  let scroll = {\n    scrollLeft: 0,\n    scrollTop: 0\n  };\n  const offsets = {\n    x: 0,\n    y: 0\n  };\n  if (isOffsetParentAnElement || !isOffsetParentAnElement && strategy !== 'fixed') {\n    if (getNodeName(offsetParent) !== 'body' || isOverflowElement(documentElement)) {\n      scroll = getNodeScroll(offsetParent);\n    }\n    if (isHTMLElement(offsetParent)) {\n      const offsetRect = getBoundingClientRect(offsetParent, true);\n      offsets.x = offsetRect.x + offsetParent.clientLeft;\n      offsets.y = offsetRect.y + offsetParent.clientTop;\n    } else if (documentElement) {\n      offsets.x = getWindowScrollBarX(documentElement);\n    }\n  }\n  return {\n    x: rect.left + scroll.scrollLeft - offsets.x,\n    y: rect.top + scroll.scrollTop - offsets.y,\n    width: rect.width,\n    height: rect.height\n  };\n}\n\nfunction getParentNode(node) {\n  if (getNodeName(node) === 'html') {\n    return node;\n  }\n  const result =\n  // Step into the shadow DOM of the parent of a slotted node\n  node.assignedSlot ||\n  // DOM Element detected\n  node.parentNode || (\n  // ShadowRoot detected\n  isShadowRoot(node) ? node.host : null) ||\n  // Fallback\n  getDocumentElement(node);\n  return isShadowRoot(result) ? result.host : result;\n}\n\nfunction getTrueOffsetParent(element) {\n  if (!isHTMLElement(element) || getComputedStyle$1(element).position === 'fixed') {\n    return null;\n  }\n  return element.offsetParent;\n}\nfunction getContainingBlock(element) {\n  let currentNode = getParentNode(element);\n  while (isHTMLElement(currentNode) && !isLastTraversableNode(currentNode)) {\n    if (isContainingBlock(currentNode)) {\n      return currentNode;\n    } else {\n      currentNode = getParentNode(currentNode);\n    }\n  }\n  return null;\n}\n\n// Gets the closest ancestor positioned element. Handles some edge cases,\n// such as table ancestors and cross browser bugs.\nfunction getOffsetParent(element) {\n  const window = getWindow(element);\n  let offsetParent = getTrueOffsetParent(element);\n  while (offsetParent && isTableElement(offsetParent) && getComputedStyle$1(offsetParent).position === 'static') {\n    offsetParent = getTrueOffsetParent(offsetParent);\n  }\n  if (offsetParent && (getNodeName(offsetParent) === 'html' || getNodeName(offsetParent) === 'body' && getComputedStyle$1(offsetParent).position === 'static' && !isContainingBlock(offsetParent))) {\n    return window;\n  }\n  return offsetParent || getContainingBlock(element) || window;\n}\n\nfunction getDimensions(element) {\n  return getCssDimensions(element);\n}\n\nfunction convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {\n  let {\n    rect,\n    offsetParent,\n    strategy\n  } = _ref;\n  const isOffsetParentAnElement = isHTMLElement(offsetParent);\n  const documentElement = getDocumentElement(offsetParent);\n  if (offsetParent === documentElement) {\n    return rect;\n  }\n  let scroll = {\n    scrollLeft: 0,\n    scrollTop: 0\n  };\n  let scale = {\n    x: 1,\n    y: 1\n  };\n  const offsets = {\n    x: 0,\n    y: 0\n  };\n  if (isOffsetParentAnElement || !isOffsetParentAnElement && strategy !== 'fixed') {\n    if (getNodeName(offsetParent) !== 'body' || isOverflowElement(documentElement)) {\n      scroll = getNodeScroll(offsetParent);\n    }\n    if (isHTMLElement(offsetParent)) {\n      const offsetRect = getBoundingClientRect(offsetParent);\n      scale = getScale(offsetParent);\n      offsets.x = offsetRect.x + offsetParent.clientLeft;\n      offsets.y = offsetRect.y + offsetParent.clientTop;\n    }\n    // This doesn't appear to need to be negated.\n    // else if (documentElement) {\n    //   offsets.x = getWindowScrollBarX(documentElement);\n    // }\n  }\n\n  return {\n    width: rect.width * scale.x,\n    height: rect.height * scale.y,\n    x: rect.x * scale.x - scroll.scrollLeft * scale.x + offsets.x,\n    y: rect.y * scale.y - scroll.scrollTop * scale.y + offsets.y\n  };\n}\n\nfunction getViewportRect(element, strategy) {\n  const win = getWindow(element);\n  const html = getDocumentElement(element);\n  const visualViewport = win.visualViewport;\n  let width = html.clientWidth;\n  let height = html.clientHeight;\n  let x = 0;\n  let y = 0;\n  if (visualViewport) {\n    width = visualViewport.width;\n    height = visualViewport.height;\n    const layoutViewport = isLayoutViewport();\n    if (layoutViewport || !layoutViewport && strategy === 'fixed') {\n      x = visualViewport.offsetLeft;\n      y = visualViewport.offsetTop;\n    }\n  }\n  return {\n    width,\n    height,\n    x,\n    y\n  };\n}\n\n// Gets the entire size of the scrollable document area, even extending outside\n// of the `<html>` and `<body>` rect bounds if horizontally scrollable\nfunction getDocumentRect(element) {\n  var _element$ownerDocumen;\n  const html = getDocumentElement(element);\n  const scroll = getNodeScroll(element);\n  const body = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;\n  const width = max(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);\n  const height = max(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);\n  let x = -scroll.scrollLeft + getWindowScrollBarX(element);\n  const y = -scroll.scrollTop;\n  if (getComputedStyle$1(body || html).direction === 'rtl') {\n    x += max(html.clientWidth, body ? body.clientWidth : 0) - width;\n  }\n  return {\n    width,\n    height,\n    x,\n    y\n  };\n}\n\nfunction getNearestOverflowAncestor(node) {\n  const parentNode = getParentNode(node);\n  if (isLastTraversableNode(parentNode)) {\n    // @ts-ignore assume body is always available\n    return node.ownerDocument.body;\n  }\n  if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) {\n    return parentNode;\n  }\n  return getNearestOverflowAncestor(parentNode);\n}\n\nfunction getOverflowAncestors(node, list) {\n  var _node$ownerDocument;\n  if (list === void 0) {\n    list = [];\n  }\n  const scrollableAncestor = getNearestOverflowAncestor(node);\n  const isBody = scrollableAncestor === ((_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.body);\n  const win = getWindow(scrollableAncestor);\n  if (isBody) {\n    return list.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : []);\n  }\n  return list.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor));\n}\n\n// Returns the inner client rect, subtracting scrollbars if present\nfunction getInnerBoundingClientRect(element, strategy) {\n  const clientRect = getBoundingClientRect(element, true, strategy === 'fixed');\n  const top = clientRect.top + element.clientTop;\n  const left = clientRect.left + element.clientLeft;\n  const scale = isHTMLElement(element) ? getScale(element) : {\n    x: 1,\n    y: 1\n  };\n  const width = element.clientWidth * scale.x;\n  const height = element.clientHeight * scale.y;\n  const x = left * scale.x;\n  const y = top * scale.y;\n  return {\n    top: y,\n    left: x,\n    right: x + width,\n    bottom: y + height,\n    x,\n    y,\n    width,\n    height\n  };\n}\nfunction getClientRectFromClippingAncestor(element, clippingAncestor, strategy) {\n  if (clippingAncestor === 'viewport') {\n    return rectToClientRect(getViewportRect(element, strategy));\n  }\n  if (isElement(clippingAncestor)) {\n    return getInnerBoundingClientRect(clippingAncestor, strategy);\n  }\n  return rectToClientRect(getDocumentRect(getDocumentElement(element)));\n}\n\n// A \"clipping ancestor\" is an `overflow` element with the characteristic of\n// clipping (or hiding) child elements. This returns all clipping ancestors\n// of the given element up the tree.\nfunction getClippingElementAncestors(element, cache) {\n  const cachedResult = cache.get(element);\n  if (cachedResult) {\n    return cachedResult;\n  }\n  let result = getOverflowAncestors(element).filter(el => isElement(el) && getNodeName(el) !== 'body');\n  let currentContainingBlockComputedStyle = null;\n  const elementIsFixed = getComputedStyle$1(element).position === 'fixed';\n  let currentNode = elementIsFixed ? getParentNode(element) : element;\n\n  // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block\n  while (isElement(currentNode) && !isLastTraversableNode(currentNode)) {\n    const computedStyle = getComputedStyle$1(currentNode);\n    const containingBlock = isContainingBlock(currentNode);\n    const shouldDropCurrentNode = elementIsFixed ? !containingBlock && !currentContainingBlockComputedStyle : !containingBlock && computedStyle.position === 'static' && !!currentContainingBlockComputedStyle && ['absolute', 'fixed'].includes(currentContainingBlockComputedStyle.position);\n    if (shouldDropCurrentNode) {\n      // Drop non-containing blocks\n      result = result.filter(ancestor => ancestor !== currentNode);\n    } else {\n      // Record last containing block for next iteration\n      currentContainingBlockComputedStyle = computedStyle;\n    }\n    currentNode = getParentNode(currentNode);\n  }\n  cache.set(element, result);\n  return result;\n}\n\n// Gets the maximum area that the element is visible in due to any number of\n// clipping ancestors\nfunction getClippingRect(_ref) {\n  let {\n    element,\n    boundary,\n    rootBoundary,\n    strategy\n  } = _ref;\n  const elementClippingAncestors = boundary === 'clippingAncestors' ? getClippingElementAncestors(element, this._c) : [].concat(boundary);\n  const clippingAncestors = [...elementClippingAncestors, rootBoundary];\n  const firstClippingAncestor = clippingAncestors[0];\n  const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {\n    const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);\n    accRect.top = max(rect.top, accRect.top);\n    accRect.right = min(rect.right, accRect.right);\n    accRect.bottom = min(rect.bottom, accRect.bottom);\n    accRect.left = max(rect.left, accRect.left);\n    return accRect;\n  }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));\n  return {\n    width: clippingRect.right - clippingRect.left,\n    height: clippingRect.bottom - clippingRect.top,\n    x: clippingRect.left,\n    y: clippingRect.top\n  };\n}\n\nconst platform = {\n  getClippingRect,\n  convertOffsetParentRelativeRectToViewportRelativeRect,\n  isElement,\n  getDimensions,\n  getOffsetParent,\n  getDocumentElement,\n  getScale,\n  async getElementRects(_ref) {\n    let {\n      reference,\n      floating,\n      strategy\n    } = _ref;\n    const getOffsetParentFn = this.getOffsetParent || getOffsetParent;\n    const getDimensionsFn = this.getDimensions;\n    return {\n      reference: getRectRelativeToOffsetParent(reference, await getOffsetParentFn(floating), strategy),\n      floating: {\n        x: 0,\n        y: 0,\n        ...(await getDimensionsFn(floating))\n      }\n    };\n  },\n  getClientRects: element => Array.from(element.getClientRects()),\n  isRTL: element => getComputedStyle$1(element).direction === 'rtl'\n};\n\n/**\n * Computes the `x` and `y` coordinates that will place the floating element\n * next to a reference element when it is given a certain CSS positioning\n * strategy.\n */\nconst computePosition = (reference, floating, options) => {\n  // This caches the expensive `getClippingElementAncestors` function so that\n  // multiple lifecycle resets re-use the same result. It only lives for a\n  // single call. If other functions become expensive, we can add them as well.\n  const cache = new Map();\n  const mergedOptions = {\n    platform,\n    ...options\n  };\n  const platformWithCache = {\n    ...mergedOptions.platform,\n    _c: cache\n  };\n  return computePosition$1(reference, floating, {\n    ...mergedOptions,\n    platform: platformWithCache\n  });\n};\n\nexport { arrow as a, computePosition as c, flip as f, offset as o, shift as s };\n","import { a as defaultLanguage } from './default-language-95a0d199.js';\n\n// Replace with cdn base path in prod\nconst LANG_BASE_URL = 'http://localhost:5000';\nconst getLangData = async (lang) => {\n  if (lang == null || lang === 'en' || lang.trim() === '') {\n    return defaultLanguage;\n  }\n  try {\n    const res = await fetch(`${LANG_BASE_URL}/${lang}.json`);\n    if (!res.ok) {\n      return defaultLanguage;\n    }\n    // merge fetched language with defaultLanguage to avoid empty properties\n    return Object.assign({}, defaultLanguage, await res.json());\n  }\n  catch (_) {\n    return defaultLanguage;\n  }\n};\n/**\n * Creates an i18n instance from a language dictionary/object.\n * @param lang The language dictionary\n * @returns A function which handles i18n\n */\nconst useLanguage = (lang = defaultLanguage) => {\n  return (key) => {\n    var _a;\n    return (_a = lang[key]) !== null && _a !== void 0 ? _a : key;\n  };\n};\n\nexport { getLangData as g, useLanguage as u };\n"],"names":["_objectWithoutProperties","source","excluded","key","i","target","sourceKeys","Object","keys","length","indexOf","getOwnPropertySymbols","sourceSymbolKeys","prototype","propertyIsEnumerable","call","getSide","placement","split","getAlignment","getMainAxisFromPlacement","includes","getLengthFromAxis","axis","computeCoordsFromPlacement","_ref","rtl","coords","reference","floating","commonX","x","width","commonY","y","height","mainAxis","commonAlign","isVertical","computePosition$1","_ref2","_asyncToGenerator","_regeneratorRuntime","mark","_callee","config","_config$placement","_config$strategy","strategy","_config$middleware","middleware","platform","validMiddleware","rects","_computeCoordsFromPla","statefulPlacement","middlewareData","resetCount","_validMiddleware$i","name","fn","_yield$fn","nextX","nextY","data","reset","_computeCoordsFromPla2","wrap","_context","prev","next","filter","Boolean","isRTL","sent","getElementRects","initialPlacement","elements","_objectSpread","_defineProperty","t0","abrupt","stop","_x","_x2","_x3","apply","arguments","getSideObjectFromPadding","padding","top","right","bottom","left","expandPaddingObject","rectToClientRect","rect","detectOverflow","_x4","_x5","_detectOverflow","_callee7","middlewareArguments","options","_await$platform$isEle","_options3","_options3$boundary","boundary","_options3$rootBoundar","rootBoundary","_options3$elementCont","elementContext","_options3$altBoundary","altBoundary","_options3$padding","paddingObject","altContext","element","clippingClientRect","offsetParent","offsetScale","elementClientRect","_context7","t1","isElement","t2","t3","t4","t5","contextElement","getDocumentElement","t6","t7","t8","t9","t10","getClippingRect","t11","getOffsetParent","getScale","t13","t12","t14","convertOffsetParentRelativeRectToViewportRelativeRect","t15","t16","min$1","Math","min","max$1","max","within","min$1$1","value","max$1$1","arrow","_callee2","_data","_ref4","_ref3","_ref3$padding","arrowDimensions","minProp","maxProp","endDiff","startDiff","arrowOffsetParent","clientSize","centerToReference","center","offset","shouldAddOffset","alignmentOffset","_context2","getDimensions","clientHeight","clientWidth","hash$1","getOppositePlacement","replace","matched","getAlignmentSides","alignment","mainAlignmentSide","main","cross","hash","start","end","getOppositeAlignmentPlacement","getExpandedPlacements","oppositePlacement","flip","_callee3","_middlewareData$flip","_options","_options$mainAxis","checkMainAxis","_options$crossAxis","checkCrossAxis","specifiedFallbackPlacements","_options$fallbackStra","fallbackStrategy","_options$flipAlignmen","flipAlignment","detectOverflowOptions","side","isBasePlacement","fallbackPlacements","placements","overflow","overflows","overflowsData","_getAlignmentSides","_middlewareData$flip$","_middlewareData$flip2","nextIndex","nextPlacement","resetPlacement","_overflowsData$map$so","_placement","_context3","crossAxis","_excluded","concat","_toConsumableArray","push","every","index","map","d","reduce","acc","sort","a","b","convertValueToCoords","_x6","_x7","_convertValueToCoords","_callee8","mainAxisMulti","crossAxisMulti","rawValue","_ref5","alignmentAxis","_context8","_callee4","diffCoords","_context4","uaString","shift","_callee5","_objectSpread3","_options2","_options2$mainAxis","_options2$crossAxis","_options2$limiter","limiter","mainAxisCoord","crossAxisCoord","maxSide","_min","_max","_maxSide","_min2","_max2","limitedCoords","_context5","_excluded2","getWindow","node","_node$ownerDocument","ownerDocument","defaultView","window","getComputedStyle$1","getComputedStyle","getNodeName","isNode","nodeName","toLowerCase","getUAString","uaData","navigator","userAgentData","Array","isArray","brands","item","brand","version","join","userAgent","isHTMLElement","HTMLElement","Element","Node","isShadowRoot","ShadowRoot","isOverflowElement","_getComputedStyle$","overflowX","overflowY","display","test","isTableElement","isContainingBlock","isFirefox","css","backdropFilter","WebkitBackdropFilter","transform","perspective","willChange","some","contain","isLayoutViewport","isLastTraversableNode","round","getCssDimensions","parseFloat","offsetWidth","offsetHeight","shouldFallback","fallback","unwrapElement","FALLBACK_SCALE","domElement","getBoundingClientRect","_getCssDimensions","Number","isFinite","includeScale","isFixedStrategy","_win$visualViewport","_win$visualViewport2","clientRect","scale","win","addVisualOffsets","visualViewport","offsetLeft","offsetTop","offsetWin","currentIFrame","frameElement","iframeScale","iframeRect","clientLeft","paddingLeft","clientTop","paddingTop","document","documentElement","getNodeScroll","scrollLeft","scrollTop","pageXOffset","pageYOffset","getWindowScrollBarX","getRectRelativeToOffsetParent","isOffsetParentAnElement","scroll","offsets","offsetRect","getParentNode","result","assignedSlot","parentNode","host","getTrueOffsetParent","position","currentNode","getContainingBlock","getNearestOverflowAncestor","body","getOverflowAncestors","list","scrollableAncestor","isBody","getClientRectFromClippingAncestor","clippingAncestor","html","layoutViewport","getViewportRect","getInnerBoundingClientRect","_element$ownerDocumen","scrollWidth","scrollHeight","direction","getDocumentRect","elementClippingAncestors","cache","cachedResult","get","el","currentContainingBlockComputedStyle","elementIsFixed","computedStyle","containingBlock","ancestor","set","getClippingElementAncestors","this","_c","clippingAncestors","firstClippingAncestor","clippingRect","accRect","_this","_callee6","getOffsetParentFn","getDimensionsFn","_context6","getClientRects","from","computePosition","Map","mergedOptions","platformWithCache","getLangData","lang","res","trim","defaultLanguage","fetch","ok","json","assign","useLanguage","undefined","_a"],"sourceRoot":""}